#include "gherkin_parser.h"
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>


#define LEN(AT, FPC) (FPC - buffer - parser->AT)
#define MARK(M,FPC) (parser->M = (FPC) - buffer)
#define PTR_TO(F) (buffer + parser->F)

/** Machine **/

%%{
  machine parser;
 
  action begin_content {
		MARK(content_start, fpc);
    parser->current_line = parser->line_number;
  }
  
  action begin_pystring_content {
    MARK(content_start, fpc);
  }

  action start_pystring {
    parser->current_line = parser->line_number;
    parser->start_col = fpc - buffer - parser->last_newline;
  }
 
  action store_pystring_content {
    if (parser->store_pystring_content != NULL) {
      int len = LEN(content_start, PTR_TO(final_newline));
      if (len >= 0) { // not an empty pystring
        parser->store_pystring_content(parser->listener, parser->start_col, PTR_TO(content_start), LEN(content_start, PTR_TO(final_newline)), parser->current_line); 
      }
      else { // Empty pystring
        parser->store_pystring_content(parser->listener, parser->start_col, PTR_TO(content_start), 0, parser->current_line); 
      } 
    }
  } 
 
  action store_feature_content {
    if (parser->store_feature_content != NULL) {
			parser->store_feature_content(parser->listener, PTR_TO(keyword_start), LEN(keyword_start, PTR_TO(keyword_end)), PTR_TO(content_start), LEN(content_start, PTR_TO(content_end)), parser->current_line);
      if(parser->content_end != 0) {
        fpc = PTR_TO(content_end - 1);
      }
      parser->content_end = 0;
    }
  }
  
  action store_background_content {
    if (parser->store_background_content != NULL) {
			parser->store_background_content(parser->listener, PTR_TO(keyword_start), LEN(keyword_start, PTR_TO(keyword_end)), PTR_TO(content_start), LEN(content_start, PTR_TO(content_end)), parser->current_line);
      if(parser->content_end != 0) {
        fpc = PTR_TO(content_end - 1);
      }
      parser->content_end = 0;
    }
  }
  
  action store_scenario_content {
    if (parser->store_scenario_content != NULL) {
			parser->store_scenario_content(parser->listener, PTR_TO(keyword_start), LEN(keyword_start, PTR_TO(keyword_end)), PTR_TO(content_start), LEN(content_start, PTR_TO(content_end)), parser->current_line);
      if(parser->content_end != 0) {
        fpc = PTR_TO(content_end - 1);
      }
      parser->content_end = 0;
    }
  }
  
  action store_scenario_outline_content {
    if (parser->store_scenario_outline_content != NULL) {
			parser->store_scenario_outline_content(parser->listener, PTR_TO(keyword_start), LEN(keyword_start, PTR_TO(keyword_end)), PTR_TO(content_start), LEN(content_start, PTR_TO(content_end)), parser->current_line);
      if(parser->content_end != 0) {
        fpc = PTR_TO(content_end - 1);
      }
      parser->content_end = 0;
    }
  }
  
  action store_examples_content {
    if (parser->store_examples_content != NULL) {
			parser->store_examples_content(parser->listener, PTR_TO(keyword_start), LEN(keyword_start, PTR_TO(keyword_end)), PTR_TO(content_start), LEN(content_start, PTR_TO(content_end)), parser->current_line);
      if(parser->content_end != 0) {
        fpc = PTR_TO(content_end - 1);
      }
      parser->content_end = 0;
    }
  }
  
  action store_step_content {
    if (parser->store_step_content != NULL) {
			parser->store_step_content(parser->listener, PTR_TO(keyword_start), LEN(keyword_start, PTR_TO(keyword_end)), PTR_TO(content_start), LEN(content_start, fpc), parser->current_line);
    }
  }
  
  action store_comment_content {
    if(parser->store_comment_content != NULL) {
      parser->store_comment_content(parser->listener, PTR_TO(content_start), LEN(content_start,fpc), parser->line_number);
    }
  }
  
  action store_tag_content {
    if (parser->store_tag_content != NULL) {
      parser->store_tag_content(parser->listener, PTR_TO(content_start), LEN(content_start, fpc), parser->line_number);
    }
  }
  
  action inc_line_number {
    parser->line_number += 1;
    MARK(final_newline, fpc);
  }
    
  action last_newline {
    MARK(last_newline, fpc + 1);
  }
 
  action start_keyword {
    if(parser->mark == 0) {
      MARK(mark, fpc);
    }
  }
  
  action end_keyword {
    MARK(keyword_end, fpc);
    MARK(keyword_start, PTR_TO(mark));
    MARK(content_start, fpc + 1);
    parser->mark = 0;
  }
  
  action next_keyword_start {
    MARK(content_end, fpc);
  }

  action start_table {
    if (parser->initialize_table != NULL) {
      p = p - 1;
      parser->current_line = parser->line_number;
      parser->initialize_table(parser);
    }
  }
  
  action begin_cell_content {
		MARK(content_start, fpc);
  }

  action store_cell_content {
    if (parser->add_cell_to_current_row != NULL) {
      parser->add_cell_to_current_row(parser, PTR_TO(content_start), LEN(content_start, fpc)); 
    }
  }

  action start_row {
    if (parser->new_row != NULL) {
      parser->new_row(parser);
    }
  }  

  action store_row {
    if (parser->end_row != NULL) {
      parser->end_row(parser);
    }
  }

  action store_table {
    if (parser->store_table != NULL) {
      parser->store_table(parser->listener, parser->table,  parser->current_line);
    }
  }

  action end_feature {
    if (cs < parser_first_final) {
      if (parser->raise_parser_error != NULL) {
        int count = 0;
        int newstr_count = 0;
        size_t len;
        const char *buff;
        if (parser->last_newline != 0) {
          len = LEN(last_newline, eof);
          buff = PTR_TO(last_newline);
        } else {
          len = strlen(buffer);
          buff = buffer;
        }
        char newstr[len]; 
        for(count = 0; count < len; count++) {
          if(buff[count] == 10) {
            newstr[newstr_count] = '\0'; // terminate new string at first newline found
            break;
          } else {
            if (buff[count] == '%') {
              newstr[newstr_count++] = buff[count];
              newstr[newstr_count] = buff[count];
            } else {
              newstr[newstr_count] = buff[count];
            }
          }
          newstr_count++;
        }
        int line = parser->line_number;
        parser_init(parser); // Otherwise you can't scan again with the same parser
                             // calling after raising doesn't do the trick.
        parser->raise_parser_error(parser->listener, newstr, line);
      }
    }
  }

  include parser_common "parser_common.<%= i18n_language %>.rl";   

}%%

/** Data **/
%% write data;

int parser_init(parser *parser) {
  int cs = 0;
  %% write init;
  parser->cs = cs;
  parser->content_start = 0;
  parser->content_end = 0;
  parser->content_len = 0;
  parser->mark = 0;
  parser->field_len = 0;
  parser->keyword_start = 0;
  parser->keyword_end = 0;
  parser->next_keyword_start = 0;
  parser->line_number = 1;
  parser->last_newline = 0;
  parser->final_newline = 0;
  parser->start_col = 0;
  
  return(1);
}

/** exec **/
size_t parser_scan(parser *parser, const char *buffer, size_t len) {
  const char *p, *pe, *eof;
  int cs = parser->cs;

  p = buffer;
  pe = buffer+len;
  eof = pe;

  assert(*pe == '\0' && "pointer does not end on NUL");
  assert(pe - p == len && "pointers aren't same distance");

  %% write exec;

  parser->cs = cs;
  
  assert(p <= pe && "buffer overflow after parsing execute");
  assert(parser->content_start <= len && "content starts after buffer end");
  assert(parser->mark < len && "mark is after buffer end");
  assert(parser->field_len <= len && "field has length longer than the whole buffer");
//  assert(parser->field_start < len && "field starts after buffer end");

// Reset parser (by re-initializing the whole thing) 
  parser_init(parser);
  
  return(parser_has_error(parser));
}

int parser_has_error(parser *parser) {
  return parser->cs == parser_error;
}
